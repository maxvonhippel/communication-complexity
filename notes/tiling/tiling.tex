\title{The Tiling Method}
\author{Max von Hippel}
\date{\today}

\documentclass[12pt]{article}

\include{header}

\begin{document}
\maketitle

\section{Problem Statement}

Consider a two-party communication problem,
	in which the participants

\begin{figure}[h]
\centering
\begin{subfigure}{.3\textwidth}
  \centering
  \includegraphics[width=.2\linewidth]{alice.png}
  \caption{Alice}
  \label{fig:alice}
\end{subfigure}%
and
\begin{subfigure}{.3\textwidth}
  \centering
  \includegraphics[width=.2\linewidth]{bob.png}
  \caption{Bob}
  \label{fig:bob}
\end{subfigure}
\label{fig:participants}
\end{figure}

\emph{participate} to compute a function:
\[f : \underbrace{\mathbb{B}^n}_{\begin{aligned}\text{Alice's}\\\text{input}\end{aligned}} \times 
      \underbrace{\mathbb{B}^n}_{\begin{aligned}\text{Bob's}\\\text{input}\end{aligned}} \to 
      \underbrace{\mathbb{B}}_{\begin{aligned}\text{global}\\\text{output}\end{aligned}}\]
The players can come up with a \emph{protocol} 
\(\Pi = (p_1, ..., p_t)\),
namely, 
	for some natural $t \in \mathbb{N}$,
	a sequence of $t$-many functions
\(p_i : \mathbb{B}^* \to \mathbb{B}^*\)
such that the communication between the players looks like this:\\
\noindent\hfill\par
\noindent\makebox[\textwidth][c]{%
    \begin{minipage}{0.65\textwidth}
\noindent\fbox{\parbox{\textwidth}{
Alice is given input $x$.
\begin{leftbubbles}
Hi Bob. I'm not divulging $x$, but, $p_1(x) = \texttt{P1}$.
\end{leftbubbles}
\rightline{Bob is given input $y$.}
\begin{rightbubbles}
Thanks Alice.  I'm not divulging $y$, but, $p_2(y, \texttt{P1}) = \texttt{P2}$.
\end{rightbubbles}
\begin{leftbubbles}
Thanks Bob.  Don't tell anyone, but: $p_3(x, \texttt{P1}, \texttt{P2}) = \texttt{P3}$.
\end{leftbubbles}
\begin{rightbubbles}
Is that so? Well, $p_4(y, \texttt{P1}, \texttt{P2}, \texttt{P3}) = \texttt{P4}$.
\end{rightbubbles}
\begin{leftbubbles}
Wicked.  In that case, $p_5(x, \texttt{P1}, \texttt{P2}, \texttt{P3}, \texttt{P4}) = \texttt{P5}$.
\end{leftbubbles}
\[... \emph{yada yada yada} ...\]
\begin{leftbubbles}
$p_t(x, \texttt{P1}, \texttt{P2}, \texttt{P3}, \texttt{P4}, ..., \texttt{P(t-1)})=\texttt{Pt}$, and TTFN!
\end{leftbubbles}}}
\end{minipage}}
Critically, the functions $p_i$ can be \emph{anything} so long as they are well-defined.
For example, $p_2$ could be the function that asks if $\langle y, \texttt{P2} \rangle$ is a word in $A_{TM}$.
\clearpage
\begin{definition}[Communication Complexity]
Suppose $\Pi$ is a protocol for $f$ in which at most $t$
bits are communicated between Alice and Bob.
Then the \emph{communication complexity} of $\Pi$,
	denoted $C(\Pi)$, is $t$.
The communication complexity of $f$, denoted $C(f)$,
	is the minimum communication complexity
	achieved by any protocol for $f$.
\end{definition}

Given some such function $f$, it would be nice if we could automatically compute
a reasonable lower bound on its communication complexity.

\section{The Tiling Method}

One way to do this is with the \emph{tiling method}.
We will give the method immediately, and in tandem, we will illustrate the method using
the function $f(x, y) = x < y$ where $x, y$ are integers in $\{ 0, 1, 2, 3 \}$, encoded in $\mathbb{B}$oolean.

\begin{definition}[$M(f)$]
The \emph{matrix of }$f$,
	denoted $M(f)$,
		is the $2^n \times 2^n$ matrix whose $(x, y)$th entry
		is the value $f(x, y)$.
\end{definition}

\begin{definition}[Combinatorial Rectangle]
A \emph{combinatorial rectangle} in $M(f)$ is any submatrix of $M$.
We say a rectangle $A \times B$ in $M(f)$ is \emph{monochromatic}
if for all $x, x'$ in $A$ and $y, y'$ in $B$, $M_{x,y} = M_{x',y'}$.
\end{definition}

Each message-send event in a protocol $\Pi$ splits $M(f)$ into two or more
combinatorial rectangles of still-possible values for $f(x, y)$.
An example is given below, using the \textsc{LeastSignficantBit} protocol for $<$,
with Alice sending the first message.

\begin{figure}[h]
\centering
\begin{forest}
[{\begin{tabular}{|l|lllll|}
\hline
    & \texttt{000}
    & \texttt{001}
    & \texttt{010}
    & \texttt{011} 
    & \texttt{100}\\\hline
\texttt{000} & \cellcolor{red!25}0 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 \\
\texttt{001} & \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 \\
\texttt{010} & \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 \\
\texttt{011} & \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{green!25}1 \\
\texttt{100} & \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0\\\hline
\end{tabular}},
	[{\begin{tabular}{|l|lllll|}
\hline
    & \texttt{000}
    & \texttt{001}
    & \texttt{010} 
    & \texttt{011}
    & \texttt{100}\\\hline
\texttt{000}  & \cellcolor{red!25}0 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 \\
\texttt{010}  & \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 \\
\texttt{100}  & \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0\\\hline
\end{tabular}}, edge label={node[midway,left]{Alice: ``$x=\_\_\texttt{0}$''}}]
	[{\begin{tabular}{|l|lllll|}
\hline
    & \texttt{000} 
    & \texttt{001}
    & \texttt{010}
    & \texttt{011}
    & \texttt{100}\\\hline
\texttt{001}  & \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 & 
                     \cellcolor{green!25}1 \\
\texttt{011}  & \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{red!25}0 & 
                     \cellcolor{green!25}1 \\\hline
\end{tabular}}, edge label={node[midway,right]{Alice: ``$x=\_\_\texttt{1}$''}}]]
\end{forest}
\caption{The matrix $M(<)$ for inputs $x, y \in \{ 0, 1, 2, 3 \}$.  Values of $x$ are given in the rows, while values of $y$ are given in the columns.  False (i.e. 0) values are marked red for clarity.  We show how in the \textsc{LeastSignificantBit} protocol, $M(<)$ can be partitioned into two rectangles depending on the substance of the initial message sent by Alice.}
\label{fig:ex:Mf}
\end{figure}

Since every protocol has finite length, 
	a run of a protocol can only split $M(f)$ finitely many times.
Hence each protocol $\Pi$ of $f$ induces a tree of combinatorial rectangles,
	rooted at $M(f)$,
	where the leaves represent the matrix of possible values of $f(x, y)$ once
	the protocol has concluded.
By definition, a protocol must conclude with both participants knowing the value $f(x, y)$.
Therefore the leaves of each such tree must be monochromatic.

Now we get to the punchline.
\begin{definition}[Monochromatic Tiling]
A \emph{monochromatic tiling} of $M(f)$ is a partition of $M(f)$ into disjoint
monochromatic rectangles.
\end{definition}

\begin{center}
\textbf{It's thinking time.}
\end{center}

\begin{description}
\item \emph{Notice} that if $\Pi$ is a protocol for $f$, then the leaves of the tree induced by $\Pi$ and rooted at $M(f)$ clearly form a monochromatic tiling of $M(f)$.
\item \emph{Recall} from eons ago, when you were an undergrad and had to know useful things, that the number of leaves in a binary tree can be used to upper-bound its depth.
\item \emph{Realize} that the depth of the binary tree induced by $\Pi$ is exactly $C(\Pi)$.
\item \emph{Observe} that although we made the math easy by assuming bit-sized messages, this idea clearly generalizes.
\end{description}

Let $\chi(f)$ denote the minimum number of rectangles in any monochromatic tiling of $M(f)$.

\begin{theorem}[The Punchline]
\[\text{log}_2 \chi(f) \leq
	C(f) \leq
		16 \big( \text{log}_2 \chi(f) \big)^2
\]
\end{theorem}

\begin{proof}
We need to show the following.
\begin{enumerate}[(a)]
	\item $\text{log}_2 \chi(f) \leq C(f)$
	\item and, $C(f) \leq 16 \big( \text{log}_2 \chi(f) \big)^2$.
\end{enumerate}
We prove (a) then (b).  Suppose that $f$ has communication complexity $C(f)$.
Then there exists a protocol $\Pi$ in which at most $C(f)$ bits are communicated
between the two participants.  For simplicity suppose each bit communicated is an individual
message.  Then $\Pi$ induces a tree whose maximum depth is $C(f)$, and which induces a monochromatic
partition of $M(f)$.  Since every monochromatic partition of $M(f)$ requires at least $\chi(f)$ rectangles, clearly the tree induced by $\Pi$ must have at least $\chi(f)$ leaves.  But we're talking about a binary tree so it immediately follows that the tree must have at least $\text{log}_2 \chi(f)$ depth.  So (a) holds and we are done.

Now let's prove (b).  Consider the function $f : \mathbb{B}^n \times \mathbb{B}^n \to \mathbb{B}$.
There are, by definition, at most $\chi(f) \geq 1$ distinct values $f(x, y)$.
\begin{description}
\item If $\chi(f) = 1$, then there is only one possible value of $f(x, y)$, and so $C(f) = 0$.
In this case we get $C(f) = 0 \leq 0 = 16 \text{log}_2^2 1 = 16 \, \text{log}_2^2 \, \chi(f)$, so (b) holds and we are done.
\item If $\chi(f) = 2$, then there are 2 possible values of $f(x, y)$, say, $\alpha$ and $\beta$.  We can partition $\mathbb{B}^n$ into the spaces $X, Y$ where if $x \in X$ then $f(x, y) = \alpha$ if and only if $y \in Y$.  Then Alice could send a single bit indicating if $x \in X$, and Bob could reply with a single bit indicating if $y \in Y$, at which point both Alice and Bob would immediately know the value of $f(x, y)$.  This protocol communication complexity 2, as only 2 bits need to be communicated.  We conclude that if $\chi(f) = 2$, then \(2 = C(f) \leq 16 \big( \text{log}_2 \, \chi(f) \big)^2 = 16 \big( \text{log}_2 \, 2 \big)^2 = 16 (1)^2 = 16\), so (b) holds and we are done.
\item For the inductive step, suppose that whenever $\chi(f) = k$ for some integer $k \geq 2$, it immediately follows that $C(f) \leq 16 \big( \text{log}_2 \chi(f) \big)^2$.  We want to show the same holds for $k + 1$.  Suppose $\chi(f) = k + 1$.  Choose some possible value $z = f(x, y)$ arbitrarily from the $\leq k + 1$ options.  Partition the space $\mathbb{B}^n$ into sets $X, y$ such that whenever $x \in X$, $f(x, y) = z$ if and only if $y \in Y$.  Have Alice send a single bit $b$ to begin the protocol, indicating if $x \in X$, and have Bob reply with a bit $b'$ indicating if $y \in Y$.  At that point if $f(x, y) = z$ the protocol is over, otherwise it reduces to a protocol over $k$ possible colors and, by our inductive assumption, (b) holds.
\end{description}
\end{proof}

Notice that the tiling method directly relates to the fooling set method.
Specifically, if $f$ has a fooling set with $m$ pairs, then $\chi(f) \geq m$.
\begin{proof}
Suppose $(x, y), (\bar{x}, \bar{y})$ are two of the pairs in the fooling set.
Then they cannot be in a monochromatic rectangle, since by definition, the following set contains at least
two distinct values:
\[\big\{ f(x, y), 
         f(x, \bar{y}),
         f(\bar{x}, y)
         f(\bar{x}, \bar{y}) \big\}\]
\end{proof}


% \bibliographystyle{IEEEtran}
% \bibliography{htm}
\end{document}